---
slug: 2025-04-27-go-generics-tutorial-4-exercise
title: (Go μ–Έμ–΄ λ‚ κ° λ‹¬κΈ°) μ λ„λ¦­(Generics) μ™„μ „ μ •λ³µ 4νΈ - μ‹¤μ „ ν™μ©κ³Ό μ£Όμμ‚¬ν•­
date: 2025-04-27T09:10:03.154Z
description: μ‹¤μ  μ½”λ“μ—μ„ μ λ„λ¦­μ„ ν™μ©ν•  λ• λ§μ£ΌμΉ  μ μλ” λ‡ κ°€μ§€ ν¥λ―Έλ΅μ΄ μ§€μ λ“¤κ³Ό, λ” κΉμ€ μ΄ν•΄λ¥Ό μ„ν• κ°λ…, κ·Έλ¦¬κ³  μ λ„λ¦­μ„ μ‚¬μ©ν•  λ• μ—Όλ‘μ— λ‘μ–΄μ•Ό ν•  μ λ“¤μ„ μ‚΄ν΄λ³΄κ² μµλ‹λ‹¤.
meta:
  keywords:
    - Go
    - Golang
    - Generics
    - μ λ„λ¦­
    - ν¬μΈν„° λ¦¬μ‹λ²„
    - Core Type
    - μ λ„λ¦­ μ£Όμμ‚¬ν•­
    - Go 1.21
published: true
---

# (Go μ–Έμ–΄ λ‚ κ° λ‹¬κΈ°) μ λ„λ¦­(Generics) μ™„μ „ μ •λ³µ 4νΈ - μ‹¤μ „ ν™μ©κ³Ό μ£Όμμ‚¬ν•­

μ•λ…•ν•μ„Έμ”!

μ§€κΈκΉμ§€ μ°λ¦¬λ” Go μ λ„λ¦­μ κΈ°λ³Έ λ¬Έλ²•λ¶€ν„° μ μ•½μ΅°κ±΄, κ·Έλ¦¬κ³  μ»΄νμΌλ¬μ λ§λ²• κ°™μ€ μΈμ¤ν„΄μ¤ν™”μ™€ νƒ€μ… μ¶”λ΅ κΉμ§€ λ§μ€ κ²ƒμ„ λ°°μ› λ”λ°μ”.

μ΄μ  μ΄λ΅ μ„ λ„μ–΄ μ‹¤μ  μ½”λ“μ—μ„ μ λ„λ¦­μ„ ν™μ©ν•  λ• λ§μ£ΌμΉ  μ μλ” λ‡ κ°€μ§€ ν¥λ―Έλ΅μ΄ μ§€μ λ“¤κ³Ό, λ” κΉμ€ μ΄ν•΄λ¥Ό μ„ν• κ°λ…, κ·Έλ¦¬κ³  μ λ„λ¦­μ„ μ‚¬μ©ν•  λ• μ—Όλ‘μ— λ‘μ–΄μ•Ό ν•  μ λ“¤μ„ μ‚΄ν΄λ³΄κ² μµλ‹λ‹¤.

λ§μ§€λ§‰κΉμ§€ μ§‘μ¤‘ν•΄μ„ ν•¨κ» μ™„μ£Όν•΄ λ³ΌκΉμ”?

## **μ‹¤μ „ ν 1: ν¬μΈν„° λ¦¬μ‹λ²„μ™€ μ λ„λ¦­, μ΅°κΈ κΉλ‹¤λ΅μ΄ λ§λ‚¨**

Goμ—μ„λ” λ©”μ„λ“λ¥Ό μ •μν•  λ• κ°’ λ¦¬μ‹λ²„(`func (t MyType) Method()`)μ™€ ν¬μΈν„° λ¦¬μ‹λ²„(`func (t *MyType) Method()`)λ¥Ό μ‚¬μ©ν•  μ μλ‹¤λ” κ²ƒμ„ κΈ°μ–µν•μ‹¤ κ²λ‹λ‹¤.

νΉν κµ¬μ΅°μ²΄μ ν•„λ“ κ°’μ„ λ³€κ²½ν•λ” λ©”μ„λ“λ” λ³΄ν†µ ν¬μΈν„° λ¦¬μ‹λ²„λ΅ μ •μν•λ”λ°μ”.

μ΄κ²ƒμ΄ μ λ„λ¦­ μ μ•½μ΅°κ±΄κ³Ό λ§λ‚  λ• μ•½κ°„μ μ£Όμκ°€ ν•„μ”ν•©λ‹λ‹¤.

2νΈμ—μ„ `fmt.Stringer` μΈν„°νμ΄μ¤λ¥Ό μ μ•½μ΅°κ±΄μΌλ΅ μ‚¬μ©ν–λ μλ¥Ό λ– μ¬λ ¤ λ΄…μ‹λ‹¤.

λ§μ•½ μ–΄λ–¤ νƒ€μ… `T`κ°€ **ν¬μΈν„° λ¦¬μ‹λ²„**λ΅ `Set(string)` λ©”μ„λ“λ¥Ό κµ¬ν„ν•κ³  μλ‹¤κ³  κ°€μ •ν•΄ λ³ΌκΉμ”?

```go
package main

import (
	"fmt"
	"strconv"
)

// κ°’μ„ μ„¤μ •ν•λ” Set λ©”μ„λ“λ¥Ό μ”κµ¬ν•λ” μΈν„°νμ΄μ¤
type Setter interface {
	Set(string)
}

// SettableInt νƒ€μ… μ •μ
type SettableInt int

// Set λ©”μ„λ“λ” *SettableInt νƒ€μ…, μ¦‰ ν¬μΈν„° λ¦¬μ‹λ²„λ΅ κµ¬ν„λμ—μµλ‹λ‹¤!
func (si *SettableInt) Set(s string) {
	i, _ := strconv.Atoi(s)
	*si = SettableInt(i)
}

// Tλ” Setter μΈν„°νμ΄μ¤λ¥Ό λ§μ΅±ν•΄μ•Ό ν•©λ‹λ‹¤.
func SetValueFromString[T Setter](value T, s string) {
	value.Set(s)
}

func main() {
	var myInt SettableInt = 0

	// SetValueFromString(myInt, "100")
	// μ»΄νμΌ μ—λ¬! SettableInt does not implement Setter (Set method has pointer receiver)
	// SettableInt νƒ€μ… μμ²΄λ” Set(string) λ©”μ„λ“λ¥Ό κ°€μ§€κ³  μμ§€ μ•μµλ‹λ‹¤. *SettableIntκ°€ κ°€μ§€κ³  μμ£ !

	// κ·ΈλΌ ν¬μΈν„° νƒ€μ…μ„ νƒ€μ… μΈμλ΅ λ„κ²¨μ£Όλ©΄ λ κΉμ”?
	// SetValueFromString[*SettableInt](&myInt, "100") // μ΄ μ½”λ“λ” μ»΄νμΌμ€ λμ§€λ§... λ­”κ°€ μ΄μƒν•©λ‹λ‹¤.

	// μ•„λμ—μ„ λ” λ‚μ€ λ°©λ²•μ„ μ•μ•„λ΄…μ‹λ‹¤.
	fmt.Println("Initial value:", myInt) // λ§μ•½ μ„ μ½”λ“λ¥Ό μ‹¤ν–‰ν–λ‹¤λ©΄? μ—¬μ „ν 0μΌ μ μμµλ‹λ‹¤!
}

```

μ„ μ½”λ“μ—μ„ `SetValueFromString(myInt, "100")` νΈμ¶μ€ μ»΄νμΌ μ—λ¬κ°€ λ‚©λ‹λ‹¤.

μ™λƒν•λ©΄ `Setter` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν• κ²ƒμ€ `SettableInt` νƒ€μ… μμ²΄κ°€ μ•„λ‹λΌ `*SettableInt` νƒ€μ…μ΄κΈ° λ•λ¬Έμ…λ‹λ‹¤.

κ·Έλμ„ `SetValueFromString[*SettableInt](&myInt, "100")` μ²λΌ ν¬μΈν„° νƒ€μ…μ„ νƒ€μ… μΈμλ΅ λ…μ‹μ μΌλ΅ λ„κ²¨μ£Όλ©΄ μ»΄νμΌμ€ ν†µκ³Όν•©λ‹λ‹¤. 

ν•μ§€λ§ μ΄ κ²½μ° `SetValueFromString` ν•¨μ λ‚΄λ¶€μ `value`λ” `*SettableInt` νƒ€μ…μ΄ λλ”λ°, **`value` μμ²΄κ°€ `nil`μΌ κ°€λ¥μ„±**μ„ κ³ λ ¤ν•΄μ•Ό ν•λ” λ“± μ¶”κ°€μ μΈ λ³µμ΅μ„±μ΄ μƒκΈΈ μ μκ³ , μλ„μ™€ λ‹¤λ¥΄κ² λ™μ‘ν•  μλ„ μμµλ‹λ‹¤.

νΉν μ λ„λ¦­ ν•¨μ λ‚΄λ¶€μ—μ„ `make([]T, ...)` μ™€ κ°™μ΄ μ λ΅ κ°’μ„ μƒμ„±ν•΄μ•Ό ν•  λ• `T`κ°€ ν¬μΈν„° νƒ€μ…μ΄λ©΄ `nil` μ¬λΌμ΄μ¤κ°€ λ§λ“¤μ–΄μ Έ λ°”λ΅ `panic`μ΄ λ°μƒν•  μ μμµλ‹λ‹¤!
(3νΈμ κ³µμ‹ λ¬Έμ„ μμ  μ„¤λ… λ¶€λ¶„ μ°Έμ΅°)

## **ν¬μΈν„° λ¦¬μ‹λ²„ λ¬Έμ λ¥Ό ν•΄κ²°ν•λ” λ” λ‚μ€ μ ‘κ·Όλ²•: λ‘ κ°μ νƒ€μ… νλΌλ―Έν„°**

μ΄λ° μƒν™©μ„ λ” μ•μ „ν•κ³  λ…ν™•ν•κ² μ²λ¦¬ν•λ” μΌλ°μ μΈ ν¨ν„΄μ€ **λ‘ κ°μ νƒ€μ… νλΌλ―Έν„°**λ¥Ό μ‚¬μ©ν•λ” κ²ƒμ…λ‹λ‹¤.

ν•λ‚λ” κΈ°λ³Έ νƒ€μ…(`T`)μ„ μ„ν• κ²ƒμ΄κ³ , λ‹¤λ¥Έ ν•λ‚λ” κ·Έ κΈ°λ³Έ νƒ€μ…μ ν¬μΈν„° νƒ€μ…μ΄λ©΄μ„ μ μ•½μ΅°κ±΄μ„ λ§μ΅±ν•λ” νƒ€μ…(`PT`)μ„ μ„ν• κ²ƒμ…λ‹λ‹¤.

```go
package main

import (
	"fmt"
	"strconv"
)

// SettableInt νƒ€μ… (λ³€κ²½ μ—†μ)
type SettableInt int

func (si *SettableInt) Set(s string) {
	i, _ := strconv.Atoi(s)
	*si = SettableInt(i)
}

// PTλ” Tμ ν¬μΈν„° νƒ€μ…μ΄μ–΄μ•Ό ν•κ³ , Set(string) λ©”μ„λ“λ¥Ό κ°€μ Έμ•Ό ν•¨μ„ λ…μ‹ν•λ” μ μ•½μ΅°κ±΄ μΈν„°νμ΄μ¤
// μΈν„°νμ΄μ¤ λ‚΄λ¶€μ— *T λ¥Ό ν¬ν•¨μ‹μΌ PTκ°€ *T νƒ€μ…μ„μ„ κ°•μ ν•©λ‹λ‹¤.
type PointerSetter[T any] interface {
	Set(string)
	*T // PT must be a pointer to T
}

// Tλ” κΈ°λ³Έ νƒ€μ…, PTλ” Tμ ν¬μΈν„° νƒ€μ…μ΄μ Setter μ—­ν• μ„ ν•λ” νƒ€μ… νλΌλ―Έν„°μ…λ‹λ‹¤.
// λ°ν™κ°’μ€ κΈ°λ³Έ νƒ€μ… Tμ μ¬λΌμ΄μ¤λΌκ³  κ°€μ •ν•΄λ΄…μ‹λ‹¤.
func CreateAndSet[T any, PT PointerSetter[T]](s string) T {
	var result T // T νƒ€μ…μ μ λ΅ κ°’μ„ μƒμ„±ν•©λ‹λ‹¤ (ν¬μΈν„°κ°€ μ•„λ‹!)
	p := PT(&result) // resultμ μ£Όμ†λ¥Ό κ°€μ Έμ™€ PT νƒ€μ… ν¬μΈν„°λ΅ λ§λ“­λ‹λ‹¤.
	p.Set(s)         // PTλ” Set λ©”μ„λ“λ¥Ό κ°€μ§€κ³  μμΌλ―€λ΅ νΈμ¶ κ°€λ¥ν•©λ‹λ‹¤.
	return result
}

func main() {
	// νƒ€μ… μΈμλ¥Ό λ‘ κ° λ¨λ‘ λ…μ‹μ μΌλ΅ μ „λ‹¬ν•©λ‹λ‹¤.
	createdInt := CreateAndSet[SettableInt, *SettableInt]("123")
	fmt.Printf("Created int: %d, Type: %T\n", createdInt, createdInt) // Created int: 123, Type: main.SettableInt

	// μ—¬κΈ°μ„ λ§λ²•! μ μ•½μ΅°κ±΄ νƒ€μ… μ¶”λ΅  λ•λ¶„μ— PT(*SettableInt)λ” μƒλµ κ°€λ¥ν•  μ μμµλ‹λ‹¤!
	// μ»΄νμΌλ¬λ” Tκ°€ SettableIntμ΄κ³ , PointerSetter[SettableInt] μ μ•½μ΅°κ±΄μ„ ν†µν•΄
	// PTκ°€ *SettableInt μ—¬μ•Ό ν•¨μ„ μ¶”λ΅ ν•  μ μμµλ‹λ‹¤. (3νΈμ—μ„ μ–ΈκΈ‰)
	createdIntSimplified := CreateAndSet[SettableInt]("456")
	fmt.Printf("Created int (simplified): %d, Type: %T\n", createdIntSimplified, createdIntSimplified) // Created int (simplified): 456, Type: main.SettableInt
}
```

μ΄ ν¨ν„΄μ„ μ‚¬μ©ν•λ©΄, μ λ„λ¦­ ν•¨μ λ‚΄λ¶€μ—μ„λ” μ•μ „ν•κ² κΈ°λ³Έ νƒ€μ… `T`μ κ°’μ„ μƒμ„±ν•κ³  λ‹¤λ£° μ μμΌλ©°, λ©”μ„λ“ νΈμ¶μ΄ ν•„μ”ν•  λ•λ§ λ…μ‹μ μΌλ΅ ν¬μΈν„° νƒ€μ… `PT`λ΅ λ³€ν™ν•μ—¬ μ‚¬μ©ν•λ―€λ΅ `nil` ν¬μΈν„° κ±±μ •μ„ λ μ μμµλ‹λ‹¤.

λ”μ± ν¥λ―Έλ΅μ΄ μ μ€, 3νΈμ—μ„ μ μ‹ μ–ΈκΈ‰ν–λ **μ μ•½μ΅°κ±΄ νƒ€μ… μ¶”λ΅ ** λ•λ¶„μ— `CreateAndSet[SettableInt]("456")` μ²λΌ λ‘ λ²μ§Έ νƒ€μ… μΈμ(`*SettableInt`)λ¥Ό μƒλµν•΄λ„ μ»΄νμΌλ¬κ°€ μ•μ•„μ„ μ¶”λ΅ ν•΄μ£Όλ” κ²½μ°κ°€ λ§λ‹¤λ” κ²ƒμ…λ‹λ‹¤!

μ μ•½μ΅°κ±΄ `PointerSetter[T]` μμ²΄κ°€ `PT`κ°€ `*T` νƒ€μ…μ΄μ–΄μ•Ό ν•λ‹¤λ” μ •λ³΄λ¥Ό λ‹΄κ³  μκΈ° λ•λ¬Έμ΄μ£ . μ •λ§ λ‘λ‘ν•μ§€ μ•μµλ‹κΉ? π‰

## **λ‚΄λ¶€ κ°λ… μ—Ώλ³΄κΈ°: μ½”μ–΄ νƒ€μ… (Core Type)**

μ λ„λ¦­μ λ‚΄λ¶€ λ™μ‘κ³Ό κ΄€λ ¨ν•μ—¬ μ•μ•„λ‘λ©΄ μΆ‹μ€ μ‹¬ν™” κ°λ… μ¤‘ ν•λ‚λ΅ **μ½”μ–΄ νƒ€μ…(Core Type)** μ΄ μμµλ‹λ‹¤.

λ¨λ“  νƒ€μ… νλΌλ―Έν„° μ μ•½μ΅°κ±΄μ΄ μ½”μ–΄ νƒ€μ…μ„ κ°€μ§€λ” κ²ƒμ€ μ•„λ‹μ§€λ§, λ§μ•½ κ°€μ§„λ‹¤λ©΄ λ‡ κ°€μ§€ μ¤‘μ”ν• λ™μ‘μ— μν–¥μ„ λ―ΈμΉ©λ‹λ‹¤.

μ½”μ–΄ νƒ€μ…μ μ •ν™•ν• μ •μλ” λ‹¤μ† λ³µμ΅ν•μ§€λ§, κ°„λ‹¨ν λ§ν•΄ **μ μ•½μ΅°κ±΄μ΄ λ‚νƒ€λ‚΄λ” νƒ€μ…λ“¤μ 'κµ¬μ΅°μ μΈ λ³Έμ§'** μ΄λΌκ³  μƒκ°ν•  μ μμµλ‹λ‹¤.

μλ¥Ό λ“¤μ–΄, `interface{ ~[]int }` μ μ•½μ΅°κ±΄μ μ½”μ–΄ νƒ€μ…μ€ `[]int` μ΄κ³ , `interface{ ~int | ~string }` μ²λΌ κµ¬μ΅°κ°€ λ‹¤λ¥Έ νƒ€μ…λ“¤μ μ λ‹μ¨μ€ μ½”μ–΄ νƒ€μ…μ„ κ°–μ§€ λ»ν•©λ‹λ‹¤.

μ½”μ–΄ νƒ€μ…μ΄ μ¤‘μ”ν• μ΄μ λ” λ‹¤μκ³Ό κ°™μµλ‹λ‹¤.

1.  **`for range` μ‚¬μ© κ°€λ¥ μ—¬λ¶€:** νƒ€μ… νλΌλ―Έν„° `T`μ— λ€ν•΄ `for range` λ£¨ν”„λ¥Ό μ‚¬μ©ν•λ ¤λ©΄, `T`μ μ μ•½μ΅°κ±΄μ΄ **λ°λ“μ‹ μ½”μ–΄ νƒ€μ…**μ„ κ°€μ Έμ•Ό ν•©λ‹λ‹¤.
    ```go
    // μ μ•½μ΅°κ±΄ Iλ” μ½”μ–΄ νƒ€μ… []intλ¥Ό κ°€μ§‘λ‹λ‹¤. -> OK
    type I1 interface{ ~[]int }
    func Loop1[T I1](x T) { for range x { /* ... */ } }

    // μ μ•½μ΅°κ±΄ I2λ” μ½”μ–΄ νƒ€μ…μ΄ μ—†μµλ‹λ‹¤. -> Compile Error!
    type I2 interface{ []int | []string }
    // func Loop2[T I2](x T) { for range x { /* ... */ } } // cannot range over x (T has no core type)
    ```
2.  **μ»΄ν¬μ§€νΈ λ¦¬ν„°λ΄(Composite Literal) μƒμ„± κ°€λ¥ μ—¬λ¶€:** `T{...}` μ™€ κ°™μ΄ νƒ€μ… νλΌλ―Έν„°λ¥Ό μ΄μ©ν•΄ λ¦¬ν„°λ΄ κ°’μ„ μƒμ„±ν•λ ¤λ©΄, ν•΄λ‹Ή μ μ•½μ΅°κ±΄μ΄ **μ½”μ–΄ νƒ€μ…**μ„ κ°€μ Έμ•Ό ν•©λ‹λ‹¤.
    ```go
    // μ μ•½μ΅°κ±΄ C1μ€ μ½”μ–΄ νƒ€μ… struct{ F int }λ¥Ό κ°€μ§‘λ‹λ‹¤. -> OK
    type C1 interface{ struct{ F int } }
    func Create1[T C1]() T { return T{F: 1} }

    // μ μ•½μ΅°κ±΄ C2λ” νƒκ·Έ μ λ¬΄λ΅ μΈν•΄ μ½”μ–΄ νƒ€μ…μ΄ μ—†μµλ‹λ‹¤. -> Compile Error!
    type C2 interface{ struct{ F int } | struct{ F int `tag` } }
    // func Create2[T C2]() T { return T{F: 1} } // cannot use composite literal type T
    ```
3.  **μ μ•½μ΅°κ±΄ νƒ€μ… μ¶”λ΅ :** 3νΈμ—μ„ μ‚΄ν΄λ³Έ μ μ•½μ΅°κ±΄ νƒ€μ… μ¶”λ΅ μ΄ μ‘λ™ν•κΈ° μ„ν• **ν•„μ μ΅°κ±΄** μ¤‘ ν•λ‚κ°€ λ°”λ΅ μ μ•½μ΅°κ±΄μ΄ μ½”μ–΄ νƒ€μ…μ„ κ°€μ§€λ” κ²ƒμ…λ‹λ‹¤.

μ½”μ–΄ νƒ€μ…μ€ μ λ„λ¦­μ λ‚΄λ¶€ λ™μ‘ λ°©μ‹μ„ μ΄ν•΄ν•λ” λ° μ¤‘μ”ν• μ—΄μ‡ μ΄μ§€λ§, μΌμƒμ μΈ μ½”λ”©μ—μ„ μ§μ ‘μ μΌλ΅ λ‹¤λ£° μΌμ€ λ§μ§€ μ•μ„ μ μμµλ‹λ‹¤.

λ‹¤λ§, `for range`λ‚ μ»΄ν¬μ§€νΈ λ¦¬ν„°λ΄ μ‚¬μ© μ‹ μμƒμΉ λ»ν• μ»΄νμΌ μ—λ¬λ¥Ό λ§λ‚λ‹¤λ©΄ μ½”μ–΄ νƒ€μ…μ λ¶€μ¬λ¥Ό μμ‹¬ν•΄λ³Ό μ μμµλ‹λ‹¤.

## **μ λ„λ¦­ μ‚¬μ© μ‹ μ£Όμν•  μ  & ν„λ…ν• ν™μ© ν**

μ λ„λ¦­μ€ κ°•λ ¥ν• λ„κµ¬μ΄μ§€λ§, λ¨λ“  λ¬Έμ λ¥Ό ν•΄κ²°ν•λ” λ§λ¥ μ—΄μ‡ λ” μ•„λ‹™λ‹λ‹¤.

ν„λ…ν•κ² μ‚¬μ©ν•κΈ° μ„ν•΄ λ‡ κ°€μ§€ μ μ„ μ—Όλ‘μ— λ‘λ©΄ μΆ‹μµλ‹λ‹¤.

1.  **λ‚¨μ©μ€ κΈλ¬Ό! κΌ­ ν•„μ”ν•  λ• μ‚¬μ©ν•©μ‹λ‹¤:** λ¨λ“  ν•¨μλ¥Ό μ λ„λ¦­μΌλ΅ λ§λ“¤ ν•„μ”λ” μ—†μµλ‹λ‹¤. μ λ„λ¦­μ΄ μ½”λ“ μ¤‘λ³µμ„ **μ‹¤μ§μ μΌλ΅** μ¤„μ—¬μ£Όκ±°λ‚ **νƒ€μ… μ•μ „μ„±**μ„ λ…ν™•ν λ†’μ—¬μ£Όλ” κ²½μ°μ— μ‚¬μ©ν•λ” κ²ƒμ΄ μΆ‹μµλ‹λ‹¤. λ•λ΅λ” κµ¬μ²΄μ μΈ νƒ€μ…μ ν•¨μ μ—¬λ¬ κ°κ°€ λ” λ…ν™•ν•κ³  μ΄ν•΄ν•κΈ° μ‰¬μΈ μ μμµλ‹λ‹¤.
2.  **μ§€λ‚μΉκ² λ³µμ΅ν• μ μ•½μ΅°κ±΄μ€ ν”Όν•©μ‹λ‹¤:** λ„λ¬΄ λ§μ€ νƒ€μ… νλΌλ―Έν„°μ™€ λ³µμ΅ν•κ² μ–½ν μ μ•½μ΅°κ±΄μ€ μ½”λ“λ¥Ό μ½κ³  μ‚¬μ©ν•κΈ° μ–΄λ µκ² λ§λ“­λ‹λ‹¤. μ μ•½μ΅°κ±΄μ€ ν•„μ”ν• λ§νΌλ§, μµλ€ν• κ°„κ²°ν•κ² μ •μν•λ” κ²ƒμ΄ μΆ‹μµλ‹λ‹¤.
3.  **ν¬μΈν„° λ¦¬μ‹λ²„ λ©”μ„λ“λ¥Ό λ‹¤μ‹ ν•λ² ν™•μΈν•©μ‹λ‹¤:** μΈν„°νμ΄μ¤ μ μ•½μ΅°κ±΄μ„ μ‚¬μ©ν•  λ•, ν•΄λ‹Ή μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” κ²ƒμ΄ κ°’ νƒ€μ…μΈμ§€ ν¬μΈν„° νƒ€μ…μΈμ§€ μ£Όμ κΉκ² ν™•μΈν•΄μ•Ό ν•©λ‹λ‹¤. μ•μ„ μ‚΄ν΄λ³Έ κ²ƒμ²λΌ μμƒμΉ λ»ν• λ™μ‘μ΄λ‚ μ»΄νμΌ μ—λ¬μ μ›μΈμ΄ λ  μ μμµλ‹λ‹¤.
4.  **μ„±λ¥ μν–¥μ€ λ―Έλ―Έν•μ§€λ§ μΈμ§€ν•©μ‹λ‹¤:** Go μ λ„λ¦­μ€ μ»΄νμΌ μ‹ μΈμ¤ν„΄μ¤ν™”λ¥Ό ν†µν•΄ ν¨μ¨μ μΌλ΅ κµ¬ν„λλ―€λ΅ λ€λ¶€λ¶„μ κ²½μ° μ„±λ¥ μ €ν•λ” κ±°μ μ—†μµλ‹λ‹¤. ν•μ§€λ§ μ•„μ£Ό κ·Ήλ‹¨μ μΈ κ³ μ„±λ¥ μ½”λ“μ—μ„λ” μ•½κ°„μ μ¤λ²„ν—¤λ“κ°€ λ°μƒν•  κ°€λ¥μ„±λ„ μ΄λ΅ μ μΌλ΅λ” μ΅΄μ¬ν•©λ‹λ‹¤. (μΌλ°μ μΈ μ›Ή κ°λ° λ“±μ—μ„λ” ν¬κ² κ±±μ •ν•  ν•„μ”λ” μ—†μµλ‹λ‹¤.)
5.  **νƒ€μ… μ¶”λ΅ μ— λ„λ¬΄ μμ΅΄ν•μ§€ λ§™μ‹λ‹¤:** νƒ€μ… μ¶”λ΅ μ€ νΈλ¦¬ν•μ§€λ§, λ•λ΅λ” λ…μ‹μ μΌλ΅ νƒ€μ… μΈμλ¥Ό μ μ–΄μ£Όλ” κ²ƒμ΄ μ½”λ“μ κ°€λ…μ„±μ„ λ†’μ΄κ³  μλ„λ¥Ό λ…ν™•ν•κ² μ „λ‹¬ν•λ” λ° λ„μ›€μ΄ λ  μ μμµλ‹λ‹¤.

## **λ―Έλλ¥Ό ν–¥ν•΄: Go μ λ„λ¦­μ μ§„ν™”μ™€ λ” κΉμ€ ν•™μµ**

Go μ λ„λ¦­μ€ Go 1.18μ—μ„ μ²μ λ„μ…λ μ΄ν›„ κ³„μ†ν•΄μ„ κ°μ„ λκ³  μμµλ‹λ‹¤.

μλ¥Ό λ“¤μ–΄ Go 1.21μ—μ„λ” νƒ€μ… μ¶”λ΅  μ•κ³ λ¦¬μ¦μ΄ λ”μ± κ°•λ ¥ν•΄μ§€κ³ , ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬μ μ μ•½μ΅°κ±΄ ν¨ν‚¤μ§€(`constraints`)κ°€ `cmp` ν¨ν‚¤μ§€λ΅ ν†µν•©λλ” λ“±μ λ³€ν™”κ°€ μμ—μµλ‹λ‹¤.

μ•μΌλ΅λ„ Go μ–Έμ–΄μ λ°μ „μ— λ”°λΌ μ λ„λ¦­μ€ λ”μ± νΈλ¦¬ν•κ³  κ°•λ ¥ν•κ² μ§„ν™”ν•  κ²ƒμΌλ΅ κΈ°λ€λ©λ‹λ‹¤.

μ λ„λ¦­μ— λ€ν•΄ λ” κΉμ΄ μ•κ³  μ‹¶λ‹¤λ©΄ μ•„λ μλ£λ“¤μ„ μ°Έκ³ ν•λ” κ²ƒμ΄ μΆ‹μµλ‹λ‹¤.

*   **Go κ³µμ‹ λ¬Έμ„ (go.dev):** μ–Έμ–΄ λ…μ„Έ(Language Specification), Effective Go, κ³µμ‹ λΈ”λ΅κ·Έμ μ λ„λ¦­ κ΄€λ ¨ ν¬μ¤νΈλ“¤μ€ κ°€μ¥ μ •ν™•ν•κ³  μ‹ λΆ°ν•  μ μλ” μ •λ³΄μ μ›μ²μ…λ‹λ‹¤.
*   **Go μ»¤λ®¤λ‹ν‹°:** Gophers Slack, Go Forum λ“±μ—μ„ λ‹¤λ¥Έ κ°λ°μλ“¤κ³Ό μ λ„λ¦­ μ‚¬μ© κ²½ν—μ„ λ‚λ„κ³  μ§λ¬Έν•λ” κ²ƒλ„ μΆ‹μ€ ν•™μµ λ°©λ²•μ…λ‹λ‹¤.

## **μ‹λ¦¬μ¦λ¥Ό λ§μΉλ©°: μ λ„λ¦­κ³Ό ν•¨κ» Go μ½”λ”© λ λ²¨ μ—…!**

κΈΈκ³ λ„ ν¥λ―Έμ§„μ§„ν–λ Go μ λ„λ¦­ νƒν— μ—¬μ •μ΄ λ“λ””μ–΄ λλ‚¬μµλ‹λ‹¤!

μ΄ μ‹λ¦¬μ¦λ¥Ό ν†µν•΄ μ—¬λ¬λ¶„μ€ μ λ„λ¦­μ κΈ°λ³Έ κ°λ…λ¶€ν„° λ‹¤μ–‘ν• μ μ•½μ΅°κ±΄ ν™μ©λ²•, λ‚΄λ¶€ λ™μ‘ μ›λ¦¬, κ·Έλ¦¬κ³  μ‹¤μ „ ν™μ© νκ³Ό μ£Όμμ‚¬ν•­κΉμ§€ ν­λ„“μ€ μ§€μ‹μ„ μ–»μΌμ…¨κΈ°λ¥Ό λ°”λλ‹λ‹¤.

μ λ„λ¦­μ€ λ‹¨μν μ½”λ“λ¥Ό μ¤„μ΄λ” κ²ƒμ„ λ„μ–΄, λ” **νƒ€μ… μ•μ „ν•κ³ **, **μ¬μ‚¬μ© κ°€λ¥ν•λ©°**, **ν‘ν„λ ¥ λ†’μ€** Go μ½”λ“λ¥Ό μ‘μ„±ν•  μ μκ² ν•΄μ£Όλ” κ°•λ ¥ν• λ„κµ¬μ…λ‹λ‹¤.

μ²μμ—λ” μ΅°κΈ λ‚―μ„¤κ² λκ»΄μ§ μ μμ§€λ§, μ¤λ λ°°μ΄ λ‚΄μ©λ“¤μ„ λ°”νƒ•μΌλ΅ μ‹¤μ  ν”„λ΅μ νΈμ— μ΅°κΈμ”© μ μ©ν•΄λ³΄λ©΄μ„ μ λ„λ¦­μ λ§¤λ ¥μ„ μ§μ ‘ λκ»΄λ³΄μ‹κΈ°λ¥Ό κ°•λ ¥ν μ¶”μ²ν•©λ‹λ‹¤!

κ·Έλ™μ• ν•¨κ» νƒν—ν•΄μ£Όμ‹  λ¨λ“  λ¶„κ» κ°μ‚¬λ“λ¦½λ‹λ‹¤.

μ•μΌλ΅ Go μ λ„λ¦­μ„ μμ μμ¬λ΅ ν™μ©ν•λ©° λ”μ± μ¦κ²κ³  ν¨μ¨μ μΈ Go κ°λ° μ—¬μ •μ„ μ΄μ–΄κ°€μ‹κΈΈ μ‘μ›ν•κ² μµλ‹λ‹¤!

κ¶κΈν• μ μ΄λ‚ λ‚λ„κ³  μ‹¶μ€ μ΄μ•ΌκΈ°κ°€ μλ‹¤λ©΄ μ–Έμ λ“ μ§€ λ“κΈ€μ„ λ‚¨κ²¨μ£Όμ„Έμ”.

κ°μ‚¬ν•©λ‹λ‹¤!