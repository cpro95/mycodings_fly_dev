---
slug: 2025-07-15-jujutsu-tutorial-for-git-users
title: Git, 이제 안녕? Jujutsu(jj) 첫걸음 튜토리얼 (Git 전문가를 위한 새로운 관점)
date: 2025-07-12 13:58:02.833000+00:00
summary: 더 이상 git add와 commit에 얽매이지 마세요. 모든 변경사항이 자동으로 커밋되고, jj undo 한 방에 모든 실수를 되돌릴 수 있는 새로운 버전 관리 도구, Jujutsu의 기본 사용법과 철학을 알아봅니다.
tags: ["Jujutsu", "Git", "jj", "버전 관리", "개발자 도구", "git-flow", "rebase"]
contributors: []
draft: false
---

Git은 의심할 여지 없이 현대 소프트웨어 개발의 표준입니다.<br /><br />
하지만 우리는 모두 알고 있습니다.<br /><br />
때로는 Git이 우리를 얼마나 괴롭게 하는지를요.<br /><br />
`git add`, `git commit`, `git rebase`, `git push`... 이 끝없는 명령어의 순환 속에서 우리는 종종 '실수하면 어떡하지?'라는 두려움을 안고 살아갑니다.<br /><br />
특히 복잡한 히스토리를 수정할 때면, 마치 살얼음판을 걷는 듯한 기분이 들기도 하죠.<br /><br />
오늘, 저는 여러분을 그 두려움에서 해방시켜 줄 새로운 도구, 'Jujutsu'(보통 `jj`로 줄여 부릅니다)를 소개하고자 합니다.<br /><br />
이것은 단순히 Git을 더 쉽게 만든 도구가 아닙니다.<br /><br />
버전 관리에 대한 우리의 '사고방식' 자체를 바꾸는, 패러다임의 전환입니다.<br /><br />
Git에 익숙한 당신이 왜 Jujutsu를 만나야 하는지, 그 첫걸음을 함께 떼어 보겠습니다.<br /><br />

## 1단계: 설치 및 기존 Git 저장소에 연결하기<br />

가장 먼저, Jujutsu를 설치해야 합니다.<br /><br />

```bash
# macOS (Homebrew 사용)
brew install jujutsu-vcs

# Linux (여러 방법이 있지만, cargo를 추천)
# https://github.com/martinvonz/jj/blob/main/docs/install.md 참조

# Windows (Scoop 또는 Winget 사용)
scoop install jujutsu
winget install --id Jujutsu.Jujutsu
```

이제 마법이 시작되는 가장 중요한 단계입니다.<br /><br />
Jujutsu는 기존 Git 저장소를 버릴 필요 없이, 그 위에 '공존'할 수 있습니다.<br /><br />
여러분의 기존 프로젝트 폴더로 이동하여 다음 명령어를 실행하세요.<br /><br />

```bash
# 기존 Git 프로젝트 안에서 실행합니다.
jj git init .
```

이 명령어는 `.jj`라는 폴더를 생성하여 Jujutsu가 Git 저장소와 함께 작동하도록 설정합니다.<br /><br />
이제 여러분은 동일한 프로젝트에서 `git` 명령어와 `jj` 명령어를 함께 사용할 수 있습니다.<br /><br />
리스크 없이 새로운 도구를 맛볼 수 있는 완벽한 방법이죠.<br /><br />

## 2단계: 패러다임의 전환 - Git과 무엇이 다른가?<br />

Jujutsu를 제대로 사용하려면, 먼저 Git과 근본적으로 다른 몇 가지 철학을 이해해야 합니다.<br /><br />

### 1. '스테이징 영역(Staging Area)'이 없습니다<br />

Git 워크플로우의 핵심은 `git add`를 통해 변경사항을 '스테이징 영역'에 올리고, `git commit`으로 확정하는 것입니다.<br /><br />
Jujutsu에는 이 개념이 아예 없습니다.<br /><br />
대신, Jujutsu는 여러분의 **모든 파일 변경사항을 항상 자동으로 추적**합니다.<br /><br />
`jj status`를 입력해 보세요.<br /><br />
여러분이 수정한 모든 파일이 이미 특별한 커밋, 즉 '워킹 카피(Working Copy)' 커밋 안에 포함되어 있는 것을 볼 수 있습니다.<br /><br />
더 이상 `git add .` 이나 `git add -p`를 반복할 필요가 없습니다.<br /><br />
그저 코드를 작성하는 행위 자체가 버전 관리의 일부가 됩니다.<br /><br />

### 2. 모든 것은 되돌릴 수 있습니다: `jj op log` & `jj undo`<br />

Git에서 `git rebase`나 `git reset --hard` 같은 '역사를 바꾸는' 명령어를 사용할 때 우리는 항상 긴장합니다.<br /><br />
실수를 되돌리려면 `reflog`라는 복잡한 미로를 헤매야 할 수도 있기 때문이죠.<br /><br />
Jujutsu는 이 모든 두려움을 없애줍니다.<br /><br />
Jujutsu에서 여러분이 하는 모든 행동(커밋 수정, 분할, 합치기 등)은 'operation log'에 기록됩니다.<br /><br />

```bash
# 내가 지금까지 jj로 한 모든 작업 내역 보기
jj op log
```

만약 실수를 했다면? 걱정할 필요 없습니다.<br /><br />

```bash
# 방금 한 작업을 취소하기
jj undo
```

이 명령어 하나면, 당신이 저지른 어떤 실수라도 마법처럼 이전 상태로 되돌아갑니다.<br /><br />
이것이 바로 Jujutsu가 '두려움 없는 버전 관리'를 가능하게 하는 핵심 기능입니다.<br /><br />

### 3. 브랜치 대신 '변경사항(Change)' 중심<br />

Git에서는 모든 작업이 '브랜치' 위에서 이루어집니다.<br /><br />
하지만 Jujutsu는 '변경사항(Change)'이라는 더 작은 단위를 중심으로 움직입니다.<br /><br />
각 변경사항은 고유한 ID를 가지며, 브랜치는 그저 특정 변경사항을 가리키는 '북마크'나 '포인터'에 가깝습니다.<br /><br />
이 덕분에 브랜치 전환(checkout) 없이도 여러 작업을 동시에 진행하고, 특정 변경사항만 콕 집어 수정하는 것이 매우 쉬워집니다.<br /><br />

## 3단계: Jujutsu 기본 워크플로우 체험하기<br />

이제 간단한 시나리오를 통해 Jujutsu의 워크플로우를 직접 경험해 보겠습니다.<br /><br />

### 1. 첫 번째 변경사항 만들기<br />

프로젝트에 새 파일을 만들거나 기존 파일을 수정해 보세요.<br /><br />
그리고 `jj log`를 입력합니다.<br /><br />

```
$ jj log
@  b1e3f7c9a2d2  (working copy)
│  (no description set)
~
```

`@` 기호는 현재 여러분의 워킹 디렉토리를 의미합니다.<br /><br />
보시다시피, 여러분의 변경사항은 이미 'b1e3f7c9a2d2'라는 ID를 가진 커밋 안에 포함되어 있습니다.<br /><br />
이제 이 변경사항에 설명을 추가해 봅시다.<br /><br />

```bash
# 현재 워킹 카피 커밋에 메시지 추가하기
jj describe -m "Add initial feature"
```

이것이 Jujutsu 스타일의 '커밋'입니다.<br /><br />
코드를 먼저 작성하고, 나중에 편할 때 설명을 붙이는 방식이죠.<br /><br />

### 2. 두 번째 변경사항 만들기<br />

계속해서 다른 파일을 수정해 보세요.<br /><br />
그리고 다시 `jj log`를 봅니다.<br /><br />
방금 한 작업은 이전 커밋 위에 새로운 '워킹 카피' 커밋으로 쌓여있을 것입니다.<br /><br />
이제 이전 작업을 '완료'하고 새로운 작업을 공식적으로 시작하고 싶다면 `jj new`를 사용합니다.<br /><br />

```bash
# 이전 커밋을 확정하고, 새로운 빈 워킹 카피 커밋을 만듭니다.
jj new -m "Start working on the next feature"
```

`jj new`는 Git의 `git add . && git commit`과 유사하지만, 훨씬 더 가볍고 빠릅니다.<br /><br />

### 3. 과거의 커밋 수정하기 (Jujutsu의 진가)<br />

이것이 바로 여러분이 Jujutsu에 반하게 될 순간입니다.<br /><br />
만약 두 번째 작업(`next feature`)을 하다가, 첫 번째 작업(`initial feature`)에 오타가 있었다는 것을 발견했다고 가정해 봅시다.<br /><br />
Git이라면 `git rebase -i`라는 복잡한 여정을 떠나야 했겠죠.<br /><br />
Jujutsu에서는 아주 간단합니다.<br /><br />

```bash
# 1. jj log로 첫 번째 커밋의 ID를 확인합니다. (예: abc1234)

# 2. 해당 커밋을 수정하겠다고 선언합니다.
jj edit abc1234

# 3. 이제 워킹 디렉토리는 첫 번째 커밋의 상태로 돌아갑니다.
#    원하는 대로 코드를 수정하세요. (오타 수정 등)

# 4. 수정이 끝났으면, 다시 최신 작업으로 돌아옵니다.
jj new
```

이게 전부입니다.<br /><br />
Jujutsu는 백그라운드에서 자동으로 리베이스를 수행하여, 여러분이 수정한 내용을 올바른 위치에 반영하고 그 위에 있던 다른 작업들을 안전하게 다시 쌓아줍니다.<br /><br />
더 이상 수동 리베이스는 없습니다.<br /><br />

## 4단계: Git과 협업하기<br />

Jujutsu로 작업한 내용을 어떻게 동료들과 공유할까요?<br /><br />
이 또한 간단합니다.<br /><br />

```bash
# 원격 저장소의 최신 변경사항을 가져옵니다.
jj git fetch

# 내 변경사항을 원격 저장소에 푸시합니다.
# --change 옵션으로 특정 변경사항(여기서는 현재 워킹 카피)을 지정합니다.
jj git push --change @
```

`jj git push`를 실행하면, Jujutsu는 해당 변경사항을 위한 새로운 브랜치를 원격 저장소에 자동으로 생성해 줍니다.<br /><br />
여러분은 더 이상 로컬 브랜치의 이름을 고민하거나 관리할 필요가 없습니다.<br /><br />

## 결론: 두려움 없는 개발을 향하여<br />

오늘 우리는 Jujutsu의 아주 기본적인 개념 맛보았습니다.<br /><br />
-   스테이징 영역 없이, 모든 변경사항이 자동으로 추적됩니다.<br /><br />
-   `jj undo`를 통해 어떤 실수든 두려움 없이 되돌릴 수 있습니다.<br /><br />
-   과거의 어떤 커밋이든 `jj edit`으로 손쉽게 수정할 수 있습니다.<br /><br />
-   브랜치 관리에 대한 부담이 거의 없습니다.<br /><br />

Jujutsu는 Git을 대체하는 것이 아니라, Git의 강력한 엔진 위에 더 현대적이고 직관적인 인터페이스를 제공하는 도구입니다.<br /><br />
이 글에서는 `jj split`(커밋 쪼개기), `jj squash`(커밋 합치기) 같은 더 강력한 기능들은 다루지 않았습니다.<br /><br />
하지만 오늘 경험한 것만으로도, Jujutsu가 여러분의 개발 워크플로우를 얼마나 극적으로 개선할 수 있는지 충분히 느끼셨을 겁니다.<br /><br />
여러분의 개인 프로젝트에 지금 바로 `jj git init .`을 실행해 보세요.<br /><br />
아마 다시는 예전의 Git 방식으로 돌아가지 못할지도 모릅니다.<br /><br />